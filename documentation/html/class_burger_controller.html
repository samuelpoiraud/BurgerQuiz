<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BurgerQuiz: BurgerController Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BurgerQuiz
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_burger_controller.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-slots">Protected Slots</a> &#124;
<a href="class_burger_controller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BurgerController Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_burger_controller.html" title="The BurgerController class Basé sur les spécifications du document 2018_10_SpecBurgerDialog.docx. ">BurgerController</a> class Basé sur les spécifications du document 2018_10_SpecBurgerDialog.docx.  
 <a href="class_burger_controller.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_burger_controller_8h_source.html">BurgerController.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BurgerController:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_burger_controller.png" usemap="#BurgerController_map" alt=""/>
  <map id="BurgerController_map" name="BurgerController_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:a05f03ceb4e332a456a76c8a1642c51f5"><td class="memItemLeft" align="right" valign="top"><a id="a05f03ceb4e332a456a76c8a1642c51f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a05f03ceb4e332a456a76c8a1642c51f5">findBurger</a> ()</td></tr>
<tr class="memdesc:a05f03ceb4e332a456a76c8a1642c51f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Déclenche la phase d'initialisation du dispositif. Cela signifie que l'automate a état est mis dans son état initial et que le contrôleur va chercher un port sur lequel se trouve un matériel compatible. Si un matériel compatible est trouvé, un PING est envoyé. <br /></td></tr>
<tr class="separator:a05f03ceb4e332a456a76c8a1642c51f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af5513782b04c37d938825fee850149"><td class="memItemLeft" align="right" valign="top"><a id="a1af5513782b04c37d938825fee850149"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a1af5513782b04c37d938825fee850149">startBlinking</a> ()</td></tr>
<tr class="memdesc:a1af5513782b04c37d938825fee850149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Déclenche le clignotement de la LED du dispositif connecté <br /></td></tr>
<tr class="separator:a1af5513782b04c37d938825fee850149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a8c772eba8bd18f3a5b08492762101413"><td class="memItemLeft" align="right" valign="top"><a id="a8c772eba8bd18f3a5b08492762101413"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a8c772eba8bd18f3a5b08492762101413">error</a> (QString)</td></tr>
<tr class="memdesc:a8c772eba8bd18f3a5b08492762101413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis au cas où une erreur se produit (matérielle ou fonctionnelle). Non implanté. <br /></td></tr>
<tr class="separator:a8c772eba8bd18f3a5b08492762101413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a68b764064ba0dc844d7cfe505210c"><td class="memItemLeft" align="right" valign="top"><a id="af1a68b764064ba0dc844d7cfe505210c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#af1a68b764064ba0dc844d7cfe505210c">initialized</a> ()</td></tr>
<tr class="memdesc:af1a68b764064ba0dc844d7cfe505210c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis après l'initialisation du dispositif. <br /></td></tr>
<tr class="separator:af1a68b764064ba0dc844d7cfe505210c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74040877649c30da426523b21f21805d"><td class="memItemLeft" align="right" valign="top"><a id="a74040877649c30da426523b21f21805d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a74040877649c30da426523b21f21805d">portOpened</a> ()</td></tr>
<tr class="memdesc:a74040877649c30da426523b21f21805d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis après l'ouverture du port de communication série vers le dispositif. <br /></td></tr>
<tr class="separator:a74040877649c30da426523b21f21805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2981f51eab0fa35472fe5f20f65d27c"><td class="memItemLeft" align="right" valign="top"><a id="af2981f51eab0fa35472fe5f20f65d27c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#af2981f51eab0fa35472fe5f20f65d27c">pingSent</a> ()</td></tr>
<tr class="memdesc:af2981f51eab0fa35472fe5f20f65d27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis lorsque le PING a été écrit dans le tampon du port de communication série. <br /></td></tr>
<tr class="separator:af2981f51eab0fa35472fe5f20f65d27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060ba7246aecf6b77749727a92c0e87d"><td class="memItemLeft" align="right" valign="top"><a id="a060ba7246aecf6b77749727a92c0e87d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a060ba7246aecf6b77749727a92c0e87d">pongReceived</a> ()</td></tr>
<tr class="memdesc:a060ba7246aecf6b77749727a92c0e87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis lorsqu'un PONG a été reçu sur le port de communication série. <br /></td></tr>
<tr class="separator:a060ba7246aecf6b77749727a92c0e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1b513c48be8604cd7637bec688cf94"><td class="memItemLeft" align="right" valign="top"><a id="aeb1b513c48be8604cd7637bec688cf94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#aeb1b513c48be8604cd7637bec688cf94">ready</a> ()</td></tr>
<tr class="memdesc:aeb1b513c48be8604cd7637bec688cf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis lorsque le dispositif est prêt, c'est-à-dire lorsque l'automate est entré dans l'état PRET. <br /></td></tr>
<tr class="separator:aeb1b513c48be8604cd7637bec688cf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f0fbf077661a2ed830ccb1ea4ad26"><td class="memItemLeft" align="right" valign="top"><a id="ade4f0fbf077661a2ed830ccb1ea4ad26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#ade4f0fbf077661a2ed830ccb1ea4ad26">buttonPressed</a> ()</td></tr>
<tr class="memdesc:ade4f0fbf077661a2ed830ccb1ea4ad26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis lorsque le bouton du dispositif a été pressé. <br /></td></tr>
<tr class="separator:ade4f0fbf077661a2ed830ccb1ea4ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030f2d6870249507a7fd8c2f5b044c60"><td class="memItemLeft" align="right" valign="top"><a id="a030f2d6870249507a7fd8c2f5b044c60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a030f2d6870249507a7fd8c2f5b044c60">selectionne</a> ()</td></tr>
<tr class="memdesc:a030f2d6870249507a7fd8c2f5b044c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal émis lorsque le dispositif a été défini comme sélectionné, c'est-à-dire lorsqu'il a été le plus rapide à buzzer. <br /></td></tr>
<tr class="separator:a030f2d6870249507a7fd8c2f5b044c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf4e6e24fe48f1b34054487036c6d9db"><td class="memItemLeft" align="right" valign="top"><a id="adf4e6e24fe48f1b34054487036c6d9db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BurgerController</b> (QObject *parent=nullptr)</td></tr>
<tr class="separator:adf4e6e24fe48f1b34054487036c6d9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fa4aa4092070ebf6c276225950bc98"><td class="memItemLeft" align="right" valign="top"><a id="a85fa4aa4092070ebf6c276225950bc98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a85fa4aa4092070ebf6c276225950bc98">initializeStateMachine</a> ()</td></tr>
<tr class="memdesc:a85fa4aa4092070ebf6c276225950bc98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise l'automate a états. <br /></td></tr>
<tr class="separator:a85fa4aa4092070ebf6c276225950bc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039595939eb6db3f8a7d0678aaad1bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a039595939eb6db3f8a7d0678aaad1bc6">debugMessage</a> (QString message)</td></tr>
<tr class="memdesc:a039595939eb6db3f8a7d0678aaad1bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formate et affiche un message de débogage dans la log.  <a href="#a039595939eb6db3f8a7d0678aaad1bc6">More...</a><br /></td></tr>
<tr class="separator:a039595939eb6db3f8a7d0678aaad1bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b339ea2816008e0f1eb830c3905d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a349b339ea2816008e0f1eb830c3905d0">isInitialized</a> () const</td></tr>
<tr class="memdesc:a349b339ea2816008e0f1eb830c3905d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne l'état du dispositif burger.  <a href="#a349b339ea2816008e0f1eb830c3905d0">More...</a><br /></td></tr>
<tr class="separator:a349b339ea2816008e0f1eb830c3905d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa933fda7493db535e0b84ef3777b485"><td class="memItemLeft" align="right" valign="top"><a id="afa933fda7493db535e0b84ef3777b485"></a>
<a class="el" href="class_burger.html">Burger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#afa933fda7493db535e0b84ef3777b485">burger</a> () const</td></tr>
<tr class="memdesc:afa933fda7493db535e0b84ef3777b485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne l'instance de burger associée à ce contrôleur. <br /></td></tr>
<tr class="separator:afa933fda7493db535e0b84ef3777b485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14bb48a342a46aaf27e4f4693bad8d"><td class="memItemLeft" align="right" valign="top"><a id="a5b14bb48a342a46aaf27e4f4693bad8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a5b14bb48a342a46aaf27e4f4693bad8d">setTeam</a> (<a class="el" href="class_burger.html#a7febe488e224415391da773904046847">Burger::Team</a> <a class="el" href="class_burger_controller.html#a3b14441af377057ac66a03f6c6d1cacd">team</a>)</td></tr>
<tr class="memdesc:a5b14bb48a342a46aaf27e4f4693bad8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Définit l'équipe associée au dispositif <a class="el" href="class_burger.html" title="Cette classe encapsule les données relatives à un burger, son état courant, l&#39;état de sa LED et son é...">Burger</a> contrôlé <br /></td></tr>
<tr class="separator:a5b14bb48a342a46aaf27e4f4693bad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b14441af377057ac66a03f6c6d1cacd"><td class="memItemLeft" align="right" valign="top"><a id="a3b14441af377057ac66a03f6c6d1cacd"></a>
<a class="el" href="class_burger.html#a7febe488e224415391da773904046847">Burger::Team</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a3b14441af377057ac66a03f6c6d1cacd">team</a> () const</td></tr>
<tr class="memdesc:a3b14441af377057ac66a03f6c6d1cacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne l'équipe associée au dispositif <a class="el" href="class_burger.html" title="Cette classe encapsule les données relatives à un burger, son état courant, l&#39;état de sa LED et son é...">Burger</a> contrôlé <br /></td></tr>
<tr class="separator:a3b14441af377057ac66a03f6c6d1cacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcd0ed64f1a51a7e93fabd568c5b0b9"><td class="memItemLeft" align="right" valign="top"><a id="a9dcd0ed64f1a51a7e93fabd568c5b0b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a9dcd0ed64f1a51a7e93fabd568c5b0b9">disableBurger</a> ()</td></tr>
<tr class="memdesc:a9dcd0ed64f1a51a7e93fabd568c5b0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Désactive le dispositif burger contrôlé <br /></td></tr>
<tr class="separator:a9dcd0ed64f1a51a7e93fabd568c5b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2150ca6568fb7e9720372df479d4d2c"><td class="memItemLeft" align="right" valign="top"><a id="ab2150ca6568fb7e9720372df479d4d2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#ab2150ca6568fb7e9720372df479d4d2c">enableBurger</a> ()</td></tr>
<tr class="memdesc:ab2150ca6568fb7e9720372df479d4d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Active le dispositif burger contrôlé <br /></td></tr>
<tr class="separator:ab2150ca6568fb7e9720372df479d4d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a29a40a531ea1701efbaabf4caa2166"><td class="memItemLeft" align="right" valign="top"><a id="a0a29a40a531ea1701efbaabf4caa2166"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a0a29a40a531ea1701efbaabf4caa2166">setSelectionne</a> ()</td></tr>
<tr class="memdesc:a0a29a40a531ea1701efbaabf4caa2166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne l'état de sélection du dispositif contrôlé <br /></td></tr>
<tr class="separator:a0a29a40a531ea1701efbaabf4caa2166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-slots"></a>
Protected Slots</h2></td></tr>
<tr class="memitem:a0b58f35589cdae0ffcb1e1f469e7344f"><td class="memItemLeft" align="right" valign="top"><a id="a0b58f35589cdae0ffcb1e1f469e7344f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a0b58f35589cdae0ffcb1e1f469e7344f">onPortOpened</a> ()</td></tr>
<tr class="memdesc:a0b58f35589cdae0ffcb1e1f469e7344f"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque le port de communication est ouvert. <br /></td></tr>
<tr class="separator:a0b58f35589cdae0ffcb1e1f469e7344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aaa0d496cd6518e9744c149589bf3f"><td class="memItemLeft" align="right" valign="top"><a id="a50aaa0d496cd6518e9744c149589bf3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a50aaa0d496cd6518e9744c149589bf3f">onPortNotOpened</a> ()</td></tr>
<tr class="memdesc:a50aaa0d496cd6518e9744c149589bf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque le prot de communication n'a pas pu être ouvert. <br /></td></tr>
<tr class="separator:a50aaa0d496cd6518e9744c149589bf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd9b6fe5df756929b807ec2b59deae7"><td class="memItemLeft" align="right" valign="top"><a id="a8cd9b6fe5df756929b807ec2b59deae7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a8cd9b6fe5df756929b807ec2b59deae7">tryNextPort</a> ()</td></tr>
<tr class="memdesc:a8cd9b6fe5df756929b807ec2b59deae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction d'itération sur la liste des ports détectés, dans le but de découvrir un dispositif burger. <br /></td></tr>
<tr class="separator:a8cd9b6fe5df756929b807ec2b59deae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34937d4313fef2991e00a0ae77efe302"><td class="memItemLeft" align="right" valign="top"><a id="a34937d4313fef2991e00a0ae77efe302"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a34937d4313fef2991e00a0ae77efe302">onDataReceived</a> (QByteArray)</td></tr>
<tr class="memdesc:a34937d4313fef2991e00a0ae77efe302"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque des données ont été reçues depuis le port de communication <br /></td></tr>
<tr class="separator:a34937d4313fef2991e00a0ae77efe302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77e5744d5b6d763456111daa18646c3"><td class="memItemLeft" align="right" valign="top"><a id="af77e5744d5b6d763456111daa18646c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#af77e5744d5b6d763456111daa18646c3">onDataWritten</a> (quint64)</td></tr>
<tr class="memdesc:af77e5744d5b6d763456111daa18646c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque des données ont été écrites dans le buffer du port de communication. <br /></td></tr>
<tr class="separator:af77e5744d5b6d763456111daa18646c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eed69626bcc432c6dcc5dac297d516"><td class="memItemLeft" align="right" valign="top"><a id="af0eed69626bcc432c6dcc5dac297d516"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#af0eed69626bcc432c6dcc5dac297d516">onPingTimeout</a> ()</td></tr>
<tr class="memdesc:af0eed69626bcc432c6dcc5dac297d516"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque le PING n'a pas reçu de réponse au bout du délai imparti (voir code source). <br /></td></tr>
<tr class="separator:af0eed69626bcc432c6dcc5dac297d516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc19980641e357d706b3c42e78a14a62"><td class="memItemLeft" align="right" valign="top"><a id="acc19980641e357d706b3c42e78a14a62"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#acc19980641e357d706b3c42e78a14a62">onStateInitialized</a> ()</td></tr>
<tr class="memdesc:acc19980641e357d706b3c42e78a14a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état INITIALISE <br /></td></tr>
<tr class="separator:acc19980641e357d706b3c42e78a14a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92abf0df34f12233d99f23eec6b596cc"><td class="memItemLeft" align="right" valign="top"><a id="a92abf0df34f12233d99f23eec6b596cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a92abf0df34f12233d99f23eec6b596cc">onEtatPortOpened</a> ()</td></tr>
<tr class="memdesc:a92abf0df34f12233d99f23eec6b596cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état PORT OUVERT <br /></td></tr>
<tr class="separator:a92abf0df34f12233d99f23eec6b596cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd845f9731314bc84ce4c9e211164991"><td class="memItemLeft" align="right" valign="top"><a id="acd845f9731314bc84ce4c9e211164991"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#acd845f9731314bc84ce4c9e211164991">onEtatPingSent</a> ()</td></tr>
<tr class="memdesc:acd845f9731314bc84ce4c9e211164991"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état PING ENVOYE <br /></td></tr>
<tr class="separator:acd845f9731314bc84ce4c9e211164991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaab797f43337bba0c651aea57012ae"><td class="memItemLeft" align="right" valign="top"><a id="aeaaab797f43337bba0c651aea57012ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#aeaaab797f43337bba0c651aea57012ae">onEtatPongReceived</a> ()</td></tr>
<tr class="memdesc:aeaaab797f43337bba0c651aea57012ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état PONG RECU <br /></td></tr>
<tr class="separator:aeaaab797f43337bba0c651aea57012ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8768183c342ca6c96089d859b65fb1ef"><td class="memItemLeft" align="right" valign="top"><a id="a8768183c342ca6c96089d859b65fb1ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a8768183c342ca6c96089d859b65fb1ef">onEtatPret</a> ()</td></tr>
<tr class="memdesc:a8768183c342ca6c96089d859b65fb1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état PRET <br /></td></tr>
<tr class="separator:a8768183c342ca6c96089d859b65fb1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33944e90f9c354cfbced130ce35a5002"><td class="memItemLeft" align="right" valign="top"><a id="a33944e90f9c354cfbced130ce35a5002"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a33944e90f9c354cfbced130ce35a5002">onEtatButtonPressed</a> ()</td></tr>
<tr class="memdesc:a33944e90f9c354cfbced130ce35a5002"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état BOUTON PRESSE <br /></td></tr>
<tr class="separator:a33944e90f9c354cfbced130ce35a5002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910ab574c1281c0fe1b48eff1c4093b7"><td class="memItemLeft" align="right" valign="top"><a id="a910ab574c1281c0fe1b48eff1c4093b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a910ab574c1281c0fe1b48eff1c4093b7">onEtatDesactive</a> ()</td></tr>
<tr class="memdesc:a910ab574c1281c0fe1b48eff1c4093b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état DESACTIVE (osbolète). <br /></td></tr>
<tr class="separator:a910ab574c1281c0fe1b48eff1c4093b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f97dcb4346237959e4eba829b5979e6"><td class="memItemLeft" align="right" valign="top"><a id="a5f97dcb4346237959e4eba829b5979e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#a5f97dcb4346237959e4eba829b5979e6">onEtatSelectionne</a> ()</td></tr>
<tr class="memdesc:a5f97dcb4346237959e4eba829b5979e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état SELECTIONNE <br /></td></tr>
<tr class="separator:a5f97dcb4346237959e4eba829b5979e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac246404276d11c7c97f60f031eefdaa3"><td class="memItemLeft" align="right" valign="top"><a id="ac246404276d11c7c97f60f031eefdaa3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#ac246404276d11c7c97f60f031eefdaa3">onEtatErreur</a> ()</td></tr>
<tr class="memdesc:ac246404276d11c7c97f60f031eefdaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">fonction appelée lorsque l'automate entre dans l'état ERREUR (non implanté) <br /></td></tr>
<tr class="separator:ac246404276d11c7c97f60f031eefdaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac894af23018583edbf9a087dcea099a9"><td class="memItemLeft" align="right" valign="top"><a id="ac894af23018583edbf9a087dcea099a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_burger_controller.html#ac894af23018583edbf9a087dcea099a9">stopBlinking</a> ()</td></tr>
<tr class="memdesc:ac894af23018583edbf9a087dcea099a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">interrompt le clognotement de la LED. Cette fonction est appelée automatiquement par le timer déclenché lors de l'appel à la fonction <a class="el" href="class_burger_controller.html#a1af5513782b04c37d938825fee850149" title="Déclenche le clignotement de la LED du dispositif connecté ">startBlinking()</a> <br /></td></tr>
<tr class="separator:ac894af23018583edbf9a087dcea099a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_burger_controller.html" title="The BurgerController class Basé sur les spécifications du document 2018_10_SpecBurgerDialog.docx. ">BurgerController</a> class Basé sur les spécifications du document 2018_10_SpecBurgerDialog.docx. </p>
<p>Ce contrôleur gère le protocole de communication avec un dispositif "Burger" et les différentes phases du jeu sous la forme d'un automate à états. une application comporte deux dispositifs <a class="el" href="class_burger.html" title="Cette classe encapsule les données relatives à un burger, son état courant, l&#39;état de sa LED et son é...">Burger</a>, chacun étant géré par une instance spécifique de ProtocolController sur un port spécifique.</p>
<p>Il ne gère pas la communication, celle-ci est gérée par la classe <a class="el" href="class_serial_port_controller.html" title="Cette classe est chargée de la communication série avec le dispositif Burger. ">SerialPortController</a>. La communication avec le port série est déplacée dans un thread dédié qui rend non bloquante la phase d'ouverture du port lorsqu'aucun dispositif n'est connecté. En revanche il effectue une découverte des dispositifs burgers connectés sur un port de communication série.</p>
<p>Ce contrôleur est associé aux cas d'utilisation suivants :</p><ul>
<li>Automate à états : [] est un état () est une transition</li>
</ul>
<p>[Etat initial] = [Non initialisé] -&gt; (init) -&gt; [Initialisation] -&gt; (port ouvert) -&gt; [Port ouvert] -&gt; (envoi du ping) -&gt; [Ping envoyé] -&gt; (réception du pong) -&gt; [Prêt] -&gt; (activation du jeu) -&gt; [En écoute] -&gt; (bouton pressé) -&gt; [Bouton pressé] -&gt; (émission signal) -&gt; [En écoute]</p>
<p>Les cas de sortie (erreur ou valides) de l'automate sont liés à</p><ul>
<li>une transition invalide (une demande d'activation alors que l'automate n'est pas à l'état prêt)</li>
<li>une erreur matérielle</li>
<li>une erreur logicielle Ces cas aboutissent à l'émission d'un signal d'erreur (non implanté actuellement).</li>
</ul>
<p>Format des trames : SOH=Start Of Header La taille des données transmises est variable et multiple de 8 bits </p><hr/>
 <h2>| Nom du champ | SOH | ID msg | Taille | Payload | EOT | </h2>
<h2>| Taille (bits) | 8 | 8 | 8 | variable | 8 | </h2>
<p>Messages : </p><hr/>
<p> | Identifiant | Valeur | Taille | Remarques | Ping | 0x16 | - | pas de payload | Pong | 0x06 | - | pas de payload | LED | 0xED | 1 | 0x00 (OFF), 0x01 (ON), 0x02 (Blink) | Button | 0xB0 | - | pas de payload </p><hr/>
<p>Exemple de messages : Ping : 01 16 00 04 Ping : 01 06 00 04 LED ON : 01 ED 01 01 04 LED OFF : 01 ED 01 00 04 LED BLINK : 01 ED 01 02 04 Button pressed : 01 B0 00 04 </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a039595939eb6db3f8a7d0678aaad1bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039595939eb6db3f8a7d0678aaad1bc6">&#9670;&nbsp;</a></span>debugMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BurgerController::debugMessage </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Formate et affiche un message de débogage dans la log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>Le message brut à afficher </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a349b339ea2816008e0f1eb830c3905d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349b339ea2816008e0f1eb830c3905d0">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BurgerController::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retourne l'état du dispositif burger. </p>
<dl class="section return"><dt>Returns</dt><dd>Vrai si le burger est initialité et prêt. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>controllers/<a class="el" href="_burger_controller_8h_source.html">BurgerController.h</a></li>
<li>controllers/BurgerController.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_burger_controller.html">BurgerController</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
